# 浏览器的线程

一直做前端开发, 对浏览器的原理有更热切的研究欲望, 这次, 我在各渠道学习的浏览器原理整理一下, 希望理顺自己对浏览器的理解.

## 浏览器的五个常驻线程

* JS线程 : 浏览器的脚本语言, 仅有一个JS线程
* 界面渲染线程 ( 有的称之为GUI ): 负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行. 提供api: rAF来在下一渲染帧执行js代码, 与主线程同步
* http请求线程: 有异步与同步
* 浏览器事件触发线程: 键盘鼠标触控
* 浏览器定时器触发线程（setTimeout）

## 相关功能:

* 数据存储:
** cookies
** 任务队列( task queue )

## 浏览器是事件驱动的（Event driven）
浏览器中很多行为是异步（Asynchronized）的，例如：鼠标点击事件、窗口大小拖拉事件、定时器触发事件、XMLHttpRequest完成回调等。当一个异步事件发生的时候，它就进入事件队列。浏览器有一个内部大消息循环，Event Loop（事件循环），会轮询大的事件队列并处理事件。

事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。

为什么是事件驱动型::
因为浏览器有http请求, ui操作, 页面渲染,
若非事件驱动,

* 主线程一直循环检测是否有请求完成, 是否有鼠标点击, 是否有页面渲染完成等等 , 这样消耗更多cpu性能
* 若线程是堵塞的/单线程的? 鼠标按下了不放就执行不了其他的

事件驱动型:

* 其他线程都异步, 完成了什么事件就把该事件对象入栈到事件收集器
* 主线程只需要循环检测事件收集器, 按顺序执行事件


## 事件队列, 任务队列( task queue )
"任务队列"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在"任务队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列"，就是读取里面有哪些事件。

内容: IO设备的事件, UI事件, 渲染事件?? 内容是事件对象, 包含有事件对象, 事件类型等等的信息??

"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。

## 合作
浏览器的多线程合作基于事件驱动的概念?

* 合作渠道: 浏览器的事件队列, 任务队列( task queue )
* JS线程是主线程
** JS线程单向给其他线程添加任务. 可以发送请求, 定时器, 模拟UI事件, 操控DOM元素( 渲染页面 ).
** JS线程循环的单向的访问任务队列:
*** 只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。以任务队列的事件配对js预先缓存了的该事件callback回调函数, 执行函数.
** 其他线程:
*** 只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

### 例子

Dan York介绍了两种典型的事件驱动实例。

#### 例子1 就诊排队

在美国去看医生，需要填写大量表格，比如保险、个人信息之类，传统的基于线程的系统（thread-based system），接待员叫到你，你需要在前台填写完成这些表格，你站着填单，而接待员坐着看你填单。你让接待员没办法接待下一个客户，除非完成你的业务。

想让这个系统能运行的快一些，只有多加几个接待员，人力成本需要增加不少。

基于事件的系统（event-based system）中，当你到窗口发现需要填写一些额外的表格而不仅仅是挂个号，接待员把表格和笔给你，告诉你可以找个座位填写，填完了以后再回去找他。你回去坐着填表，而接待员开始接待下一个客户。你没有阻塞接待员的服务。

你填完表格，返回队伍中，等接待员接待完现在的客户，你把表格递给他。如果有什么问题或者需要填写额外的表格，他给你一份新的，然后重复这个过程。

这个系统已经非常高效了，几乎大部分医生都是这么做的。如果等待的人太多，可以加入额外的接待员进行服务，但是肯定要比基于线程模式的少得多。


#### 例子2 快餐店点餐

在基于线程的方式中（thread-based way）你到了柜台前，把你的点餐单给收银员或者给收银员直接点餐，然后等在那直到你要的食物准备好给你。收银员不能接待下一个人，除非你拿到食物离开。想接待更多的客户，容易！加更多的收银员！

当然，我们知道快餐店其实不是这样工作的。他们其实就是基于事件驱动方式，这样收银员更高效。只要你把点餐单给收银员，某个人已经开始准备你的食物，而同时收银员在进行收款，当你付完钱，你就站在一边而收银员已经开始接待下一个客户。在一些餐馆，甚至会给你一个号码，如果你的食物准备好了，就呼叫你的号码让你去柜台取。关键的一点是，你没有阻塞下一个客户的订餐请求。你订餐的食物做好的事件会导致某个人做某个动作（某个服务员喊你的订单号码，你听到你的号码被喊到去取食物），在编程领域，我们称这个为回调（callback function）。

## 传统的线程模型

传统服务器模型如Apache为每一个请求生成一个子进程。当用户连接到服务器的一个子进程就产生，并处理连接。每个连接获得一个单独的线程和子进程。当用户请求数据返回时，子进程开始等待数据库操作返回。如果此时另一个用户也请求返回数据，这时就产生了阻塞。

传统的线程模型是基于运行应用程序是的一些密集型操作的需要。操作系统的设计是让用户执行的多线程程序，使后台文件写入和UI操作同时进行，而并不是设计于处理大量并发请求连接。我理解是:传统线程是window的模式, 多线程是为了处理大型的程序如同时运行迅雷qq实况足球.

创建多进程会带来另外一个问题：内存消耗。
一个配置不当的服务器，很容易遭受拒绝服务攻击（DoS）。当大量并发请求的服务器资源时，负载均衡配置不当时服务器会很快耗尽源而奔溃。

Fork和多线程是相当费资源的操作，创建线程需要分配一个全新的内存堆栈。此外，上下文切换也是一项开销的，CPU调度模型是并不太适合一个传统的Web服务器。

目前应用最广的传统模型的Apache+PHP服务器

## 发展新模型:

两个流行事件驱动模型服务器Node.js，tornado

这种模型虽然是单线程运行，但是能更高效的利用CPU处理更多的并发请求。

新模型抛弃了对每个请求生成子进程的想法。所有的请求和事物操作只使用一个单独的线程管理，此线程被称之为事件循环。

事件循环将异步的管理所有用户连接与文件存储或数据库服务器。当请求到达时，使用poll或者select唤醒操作系统对其请求做相应处理。

这样以来处理的并发请求不再是紧紧围绕在阻塞资源。

这样也有一定的开销，如保持一个始终打开的TCP连接的列表，但内存并不会由于大量并发请求而急速上升，因为这个列表只占内存堆上很小的一部分。

nodejs的不足:

多线程的实现
Node.js运行于Google的V8 Javascript引擎上( 服务于浏览器的 ), 决定了nodejs难以实现多线程

Apache的最初目的是以一切可利用的资源为代价充分高效管理并发和线程。事件驱动模型服务器避开了这种繁琐的设计而用最简洁高效的方式实现了可扩展性良好的服务器。
我理解是:

* 传统模式 : 尽力做好做全每一个任务, 每个任务都有主线程负责处理.
* Nodejs模式: 主线程专注于响应( 包括启动与完成响应 ), 但具体处理交给其他具体的引擎处理 ( 意味处理的引擎没有主线程的全面能力 )

事件驱动模型的出现，是为了解决传统服务器与网络工作负载的需求的不匹配，实现高度可伸缩服务器，并降低内存开销。事情驱动模型更改了连接到服务器的方式。所有的连接都由事件循环管理，每个连接触发一个在事件循环进程中运行的事件，而不是为每个连接生成一个新的 OS 线程，并为其分配一些配套内存。因此不用担心出现死锁，而且不会直接调用阻塞资源，而采用异步的方式来实现非阻塞式I/O。通过事件驱动模型是的在相同配置的服务器能接受更多的并发请求，实现可伸缩的服务器。

事件驱动型, 保留主线程永远有能力处理网络请求等等的, 不会有假死情况, 提供了服务器的高并发能力.
